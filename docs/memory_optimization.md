# 메모리 최적화 설계 문서

## generate_proof 함수의 인자 설계

### 두 가지 접근 방식 비교

#### 1. Handle 방식 (채택하지 않음)

```rust
pub fn generate_proof(
    pk_handle: u64,          // KeyManager에서 관리되는 handle
    anchor_handle: u64,
    schnorr_handle: u64,
    // witness...
) -> Result<Vec<u8>, ApplicationError>
```

**장점:**
- 동일한 키를 여러 번 사용할 때 로드 오버헤드 없음
- KeyManager의 deduplication 활용 가능
- 한 번 로드된 키는 빠르게 접근 가능

**단점:**
- 키가 메모리에 계속 상주 (Arc로 참조 유지)
- Proving Key는 매우 큼 (500MB ~ 2GB)
- 모바일에서 메모리 압박 발생
- 명시적으로 해제하지 않으면 메모리 누수 가능성
- 여러 앱이 동시에 메모리 사용 시 시스템 불안정

**메모리 사용 예시:**
```
App 시작: 100MB
PK 로드 (handle): 100MB + 1GB = 1.1GB
증명 생성: 1.1GB + 500MB (임시) = 1.6GB
증명 완료: 1.1GB (PK는 여전히 메모리에 상주)
```

#### 2. File Path 방식 (채택)

```rust
pub fn generate_proof(
    pk_path: String,           // 파일 경로로 직접 전달
    anchor_key_path: String,
    schnorr_key_path: String,
    // witness...
) -> Result<Vec<u8>, ApplicationError>
```

**장점:**
- 필요할 때만 로드, 사용 후 자동 해제
- 메모리 사용량 최소화
- 함수 종료 시 자동으로 메모리 반환
- 여러 증명을 순차적으로 생성해도 메모리 안정적
- 모바일 환경에 적합

**단점:**
- 매번 파일 로드 오버헤드 (1-3초)
- 동일한 키를 여러 번 로드 시 비효율적

**메모리 사용 예시:**
```
App 시작: 100MB
증명 생성 시작: 100MB
PK 로드: 100MB + 1GB = 1.1GB
증명 생성: 1.1GB + 500MB (임시) = 1.6GB
증명 완료: 100MB (모든 리소스 자동 해제)
```

### 사용 시나리오별 분석

#### 시나리오 1: 단일 증명 생성 (일반적)

- **Handle 방식**: 메모리 1.1GB 유지 → ❌ 과도함
- **File Path 방식**: 메모리 피크만 1.6GB, 평소 100MB → ✅ 효율적

#### 시나리오 2: 연속된 여러 증명 생성

- **Handle 방식**: 메모리 1.1GB + N * 500MB → ❌ OOM 위험
- **File Path 방식**: 각 증명마다 독립적, 최대 1.6GB → ✅ 안정적

#### 시나리오 3: 백그라운드에서 증명 생성

- **Handle 방식**: 앱 전체가 1.1GB 추가 사용 → ❌ 다른 기능 영향
- **File Path 방식**: 필요한 순간만 메모리 사용 → ✅ 다른 기능과 격리

### 모바일 환경 고려사항

#### 일반적인 모바일 메모리

- **iOS**: 2-6GB RAM
- **Android**: 4-8GB RAM (중저가폰 2-4GB)
- **OS 예약**: ~1GB
- **다른 앱**: ~1-2GB
- **사용 가능**: ~2-4GB

#### Handle 방식 사용 시

```
OS: 1GB
다른 앱: 1.5GB
앱 기본: 0.5GB
PK 캐시: 1GB
증명 생성: 0.5GB
------------------------
총 사용: 4.5GB → 일부 디바이스에서 OOM
```

#### File Path 방식 사용 시

```
OS: 1GB
다른 앱: 1.5GB
앱 기본: 0.5GB
증명 생성 피크: 1.5GB
------------------------
총 사용: 4.5GB (피크 시만)
평소: 3GB → 안정적
```

### 성능 측정 (예상)

| 작업 | Handle 방식 | File Path 방식 |
|------|-------------|----------------|
| 첫 증명 생성 | 3-5초 | 4-6초 (로드 1-2초 포함) |
| 두 번째 증명 | 2-3초 | 4-6초 |
| 메모리 평균 | 1.2GB | 0.15GB |
| 메모리 피크 | 1.7GB | 1.6GB |

### 결론

**File Path 방식을 채택한 이유:**

1. ✅ **메모리 효율성**: 평소 메모리 사용량 최소화
2. ✅ **안정성**: OOM 위험 감소
3. ✅ **격리성**: 증명 생성이 다른 기능에 영향 최소화
4. ✅ **모바일 최적화**: 제한된 리소스에 적합
5. ⚠️ **성능**: 로드 시간 1-2초 추가 (허용 가능한 수준)

### 향후 최적화 고려사항

필요시 하이브리드 접근 가능:

```rust
// 옵션 1: 캐시 사용 (서버/고성능 환경)
pub fn generate_proof_with_cache(handle: u64, ...) -> Result<Vec<u8>, Error>

// 옵션 2: 메모리 최적화 (모바일)
pub fn generate_proof(pk_path: String, ...) -> Result<Vec<u8>, Error>
```

하지만 현재는 **모바일 우선** 설계로 File Path 방식만 제공합니다.
